**public static void main(String[] args) 是什么意思？**

这是 Java 程序的入口地址，Java 虚拟机运行程序的时候首先找的就是 main 方法。跟 C 语言里面的 main() 函数的作用是一样的。只有有 main() 方法的 Java 程序才能够被 Java 虚拟机运行，可理解为规定的格式。

对于里面的参数及修饰符：

-  **public**：表示的这个程序的访问权限，表示的是任何的场合可以被引用，这样 Java 虚拟机就可以找到 main() 方法,从而来运行 **javac** 程序。
-  **static**： 表明方法是静态的，不依赖类的对象的，是属于类的，在类加载的时候 main() 方法也随着加载到内存中去。
-  **void:main()**：方法是不需要返回值的。
-  **main**：约定俗成，规定的。
-  **String[] args**：从控制台接收参数。





面向对象程序设计的 3 个主要特征：**封装性、继承性、多态性**。

**封装性（encapsulation）：**封装是一种信息隐蔽技术，它体现于类的说明，是对象的重要特性。封装使数据和加工该数据的方法（函数）封装为一个整体，以实现独立性很强的模块，使得用户只能见到对象的外特性（对象能接受哪些消息，具有哪些处理能力），而对象的内特性（保存内部状态的私有数据和实现加工能力的算法）对用户是隐蔽的。封装的目的在于把对象的设计者和对象的使用者分开，使用者不必知晓其行为实现的细节，只须用设计者提供的消息来访问该对象。

**继承性：**继承性是子类共享其父类数据和方法的机制。它由类的派生功能体现。一个类直接继承其他类的全部描述，同时可修改和扩充。继承具有传递性。继承分为单继承（一个子类有一父类）和多重继承（一个类有多个父类）。类的对象是各自封闭的，如果没继承性机制，则类的对象中的数据、方法就会出现大量重复。继承不仅支持系统的可重用性，而且还促进系统的可扩充性。

**多态性：**对象根据所接收的消息而做出动作。同一消息被不同的对象接受时可产生完全不同的行动，这种现象称为多态性。利用多态性用户可发送一个通用的信息，而将所有的实现细节都留给接受消息的对象自行决定，如是，同一消息即可调用不同的方法。例如：同样是 run 方法，飞鸟调用时是飞，野兽调用时是奔跑。多态性的实现受到继承性的支持，利用类继承的层次关系，把具有通用功能的协议存放在类层次中尽可能高的地方，而将实现这一功能的不同方法置于较低层次，这样，在这些低层次上生成的对象就能给通用消息以不同的响应。在 OOPL 中可通过在派生类中重定义基类函数（定义为重载函数或虚函数）来实现多态性。





**JDK 和 JRE 的区别**

**JRE(Java Runtime Enviroment)** 是 Java 的运行环境。面向 Java 程序的使用者，而不是开发者。如果你仅下载并安装了JRE，那么你的系统只能运行 Java 程序。JRE 是运行 Java 程序所必须环境的集合，包含JVM标准实现及 Java 核心类库。它包括 Java 虚拟机、Java 平台核心类和支持文件。它不包含开发工具(编译器、调试器等)。

**JDK(Java Development Kit)** 又称 J2SDK(Java2 Software Development Kit)，是 Java 开发工具包，它提供了 Java 的开发环境(提供了编译器 javac 等工具，用于将 java 文件编译为 class 文件)和运行环境(提 供了 JVM 和 Runtime 辅助包，用于解析 class 文件使其得到运行)。如果你下载并安装了 JDK，那么你不仅可以开发 Java 程序，也同时拥有了运行 Java 程序的平台。JDK 是整个 Java 的核心，包括了Java 运行环境(JRE)，一堆 Java 工具 tools.jar 和 Java 标准类库 (rt.jar)。



类、对象、方法和实例变量的概念：

- **对象**：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
- **类**：类是一个模板，它描述一类对象的行为和状态。
- **方法**：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。
- **实例变量**：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。



## Java 标识符

Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。

关于 Java 标识符，有以下几点需要注意：

- 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始
- 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合
- 关键字不能用作标识符
- 标识符是大小写敏感的
- 合法标识符举例：age、$salary、_value、__1_value
- 非法标识符举例：123abc、-salary



## Java修饰符

像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：

- 访问控制修饰符 : default, public , protected, private
- 非访问控制修饰符 : final, abstract, static, synchronized





## Java 变量

Java 中主要有如下几种类型的变量

- 局部变量
- 类变量（静态变量）
- 成员变量（非静态变量）



一个类可以包含以下类型变量：

- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
- **类变量**：类变量也声明在类中，方法体之外，但必须声明为static类型。



**成员变量和类变量的区别**





由static修饰的变量称为静态变量，其实质上就是一个全局变量。如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；没有被静态修饰的内容，其实是属于对象的特殊描述。

不同的对象的实例变量将被分配不同的内存空间， 如果类中的成员变量有类变量，那么所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量，也就是说对象共享类变量。

成员变量和类变量的区别：

   1、两个变量的生命周期不同

​      成员变量随着对象的创建而存在，随着对象的回收而释放。

​      静态变量随着类的加载而存在，随着类的消失而消失。

   2、调用方式不同

​      成员变量只能被对象调用。

​      静态变量可以被对象调用，还可以被类名调用。

   3、别名不同

​      成员变量也称为实例变量。

​      静态变量也称为类变量。

   4、数据存储位置不同

​      成员变量存储在堆内存的对象中，所以也叫对象的特有数据。

​      静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。





static 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。

   特点：

   1、想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。

   2、被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。

​    3、静态随着类的加载而加载。而且优先于对象存在。

 

弊端：

   1、有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。

   2、静态方法只能访问静态成员，不可以访问非静态成员。

​      因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。

   3、静态方法中不能使用this，super关键字。

​      因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。

 

什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？

成员分两种：

   1、成员变量。（数据共享时静态化）

​      该成员变量的数据是否是所有对象都一样：

​      如果是，那么该变量需要被静态修饰，因为是共享的数据。 

​      如果不是，那么就说这是对象的特有数据，要存储到对象中。 

   2、成员函数。（方法中没有调用特有数据时就定义成静态）

​      如果判断成员函数是否需要被静态修饰呢？

​      只要参考，该函数内是否访问了对象中的特有数据：

​      如果有访问特有数据，那方法不能被静态修饰。

​      如果没有访问过特有数据，那么这个方法需要被静态修饰。



成员变量和静态变量的区别：

   1、成员变量所属于对象。所以也称为实例变量。

​      静态变量所属于类。所以也称为类变量。

   2、成员变量存在于堆内存中。

​      静态变量存在于方法区中。

   3、成员变量随着对象创建而存在。随着对象被回收而消失。

​      静态变量随着类的加载而存在。随着类的消失而消失。

   4、成员变量只能被对象所调用 。

​      静态变量可以被对象调用，也可以被类名调用。

   所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。



1.局部变量：在方法、构造方法、语句块中定义的变量。其声明和初始化在方法中实现，在方法结束后自动销毁

```
public class  ClassName{
    public void printNumber（）{
        int a;
    }
    // 其他代码
}
```

2.成员变量：定义在类中，方法体之外。变量在创建对象时实例化。成员变量可被类中的方法、构造方法以及特定类的语句块访问。

```
public class  ClassName{
    int a;
    public void printNumber（）{
        // 其他代码
    }
}
```

3.类变量：定义在类中，方法体之外，但必须要有 static 来声明变量类型。静态成员属于整个类，可通过对象名或类名来调用。

```
public class  ClassName{
    static int a;
    public void printNumber（）{
        // 其他代码
    }
}
```



## 继承

在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。

利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。



## 接口

在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。

接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。



**常用的转义字符：**

```
"\b" (退格)
"\f" (换页)
"\n" (换行)
"\r" (回车)
"\t" (水平制表符(到下一个tab位置))
"\' " (单引号)
"\" " (双引号) 
"\\" (反斜杠)
```



Java的八种基本类型：（按字节来分）

boolean   布尔型   1个字节 8bit（8位）

byte     字节类型   1个字节

char     字符类型   2个字节

short     短整型     2个字节

int          整型        4个字节

float      浮点型（单精度）4个字节

long      长整型      8个字节

double   双精度类型  8个字节

Java中默认的整数类型是int，如果要定义为long ，则要在数值后加上L或者l

默认的浮点型是双精度浮点，如果要定义float，则要在数值后面加上f或者F

一个字节等于8位，1个字节等于256个数。2^8

一个英文字母或者阿拉伯数字占一个字节

一个汉字占2个字节



**数据类型的溢出**

在 Java 中，只有数字类型才能参与运算。但是每个数据类型都有他的取值范围。

例如 byte 数据类型，它的取值范围为 **-128 - 127** 。

当我们使用 **byte b = 128;** 时，肯定会报错。

但是使用 **byte b = 127+1;** 并不会报错。

而且运算的结果为 **-128**。

我们可以向数据类型的取值范围看作是一个圆，每多一个数据向前移动一个，当数据达到最大值时，我们再加 1，可以就会变成最小值，这就是数据的溢出。





## 构造方法

每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。

在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。



## 创建对象

对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：

- **声明**：声明一个对象，包括对象名称和对象类型。
- **实例化**：使用关键字new来创建一个对象。
- **初始化**：使用new创建对象时，会调用构造方法初始化对象。



## 访问实例变量和方法

通过已创建的对象来访问成员变量和成员方法，如下所示：

```
/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
```





引用类型是一个对象类型，它的值是指向内存空间的引用，就是地址，所指向的内存中保存着变量所表示的一个值或一组值。



引用类型变量在声明后必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问。





Java语言支持的变量类型有：

- 类变量：独立于方法之外的变量，用 static 修饰。
- 实例变量：独立于方法之外的变量，不过没有 static 修饰。
- 局部变量：类的方法中的变量。





## Java 局部变量

- 局部变量声明在方法、构造方法或者语句块中；
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量只在声明它的方法、构造方法或者语句块中可见；
- 局部变量是在栈上分配的。
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。



## 实例变量

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
- 实例变量可以声明在使用前或者使用后；
- 访问修饰符可以修饰实例变量；
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。



## 类变量（静态变量）

- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
- 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。
- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
- 静态变量在第一次被访问时创建，在程序结束时销毁。
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
- 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：*ClassName.VariableName*的方式访问。
- 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。



| **成员变量** | **局部变量**   | **静态变量**              |                    |
| ------------ | -------------- | ------------------------- | ------------------ |
| 定义位置     | 在类中,方法外  | 方法中,或者方法的形式参数 | 在类中,方法外      |
| 初始化值     | 有默认初始化值 | 无,先定义,赋值后才能使用  | 有默认初始化值     |
| 调用方式     | 对象调用       | ---                       | 对象调用，类名调用 |
| 存储位置     | 堆中           | 栈中                      | 方法区             |
| 生命周期     | 与对象共存亡   | 与方法共存亡              | 与类共存亡         |
| 别名         | 实例变量       | ---                       | 类变量             |



**是否可以从一个static方法内部无法对非static方法的调用?**

不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部无法对非static方法的调用。